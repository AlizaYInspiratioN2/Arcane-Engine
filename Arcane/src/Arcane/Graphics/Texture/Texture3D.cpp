#include "arcpch.h"
#include "Texture3D.h"

namespace Arcane
{
	Texture3D::Texture3D() : m_Texture3DId(0), m_Texture3DTarget(GL_TEXTURE_3D), m_Width(0), m_Height(0), m_Depth(0), m_Texture3DSettings() {}

	Texture3D::Texture3D(Texture3DSettings& settings) : m_Texture3DId(0), m_Texture3DTarget(GL_TEXTURE_3D), m_Width(0), m_Height(0), m_Depth(0), m_Texture3DSettings(settings) {}

	// TODO: Current Texture Copy implementation only copies the highest resolution mip (level 0)
	// This implementation is fine when the hardware generates the mips because our newly created texture will do the same
	// This only fails if the mip levels contain custom data that was generated by the hardware via glGenerateMipmap(...)
	Texture3D::Texture3D(const Texture3D& texture) : m_Texture3DId(0), m_Texture3DTarget(texture.GetTextureTarget()), m_Width(texture.GetWidth()), m_Height(texture.GetHeight()), m_Depth(texture.GetDepth()), m_Texture3DSettings(texture.GetTextureSettings())
	{
		glGenTextures(1, &m_Texture3DId);
		Bind();

		glTexImage3D(m_Texture3DTarget, 0, m_Texture3DSettings.TextureFormat, m_Width, m_Height, m_Depth, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
		ApplyTextureSettings();
		glCopyImageSubData(texture.GetTextureId(), texture.GetTextureTarget(), 0, 0, 0, 0, m_Texture3DId, m_Texture3DTarget, 0, 0, 0, 0, m_Width, m_Height, m_Depth);

		Unbind();
	}

	Texture3D::~Texture3D()
	{
		glDeleteTextures(1, &m_Texture3DId);
	}

	void Texture3D::ApplyTextureSettings()
	{
		// Texture wrapping
		glTexParameteri(m_Texture3DTarget, GL_TEXTURE_WRAP_S, m_Texture3DSettings.TextureWrapSMode);
		glTexParameteri(m_Texture3DTarget, GL_TEXTURE_WRAP_T, m_Texture3DSettings.TextureWrapTMode);
		glTexParameteri(m_Texture3DTarget, GL_TEXTURE_WRAP_R, m_Texture3DSettings.TextureWrapRMode);
		if (m_Texture3DSettings.HasBorder)
		{
			glTexParameterfv(m_Texture3DTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(m_Texture3DSettings.BorderColour));
		}

		// Texture filtering
		glTexParameteri(m_Texture3DTarget, GL_TEXTURE_MIN_FILTER, m_Texture3DSettings.TextureMinificationFilterMode);
		glTexParameteri(m_Texture3DTarget, GL_TEXTURE_MAG_FILTER, m_Texture3DSettings.TextureMagnificationFilterMode);

		// Mipmapping
		if (m_Texture3DSettings.HasMips)
		{
			glGenerateMipmap(m_Texture3DTarget);
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_LOD_BIAS, m_Texture3DSettings.MipBias);
		}
	}

	void Texture3D::Generate3DTexture(unsigned int width, unsigned int height, unsigned int depth, GLenum dataFormat, GLenum pixelDataType, const void* data)
	{
		m_Texture3DTarget = GL_TEXTURE_3D;
		m_Width = width;
		m_Height = height;
		m_Depth = depth;

		// If GL_NONE is specified, set the texture format to the data format
		if (m_Texture3DSettings.TextureFormat == GL_NONE)
		{
			m_Texture3DSettings.TextureFormat = dataFormat;
		}
		// Check if the texture is SRGB, if so change the texture format
		if (m_Texture3DSettings.IsSRGB)
		{
			switch (dataFormat)
			{
			case GL_RGB: m_Texture3DSettings.TextureFormat = GL_SRGB; break;
			case GL_RGBA: m_Texture3DSettings.TextureFormat = GL_SRGB_ALPHA; break;
			}
		}

		glGenTextures(1, &m_Texture3DId);
		Bind();

		glTexImage3D(GL_TEXTURE_3D, 0, m_Texture3DSettings.TextureFormat, width, height, depth, 0, dataFormat, pixelDataType, data);
		ApplyTextureSettings();

		Unbind();
	}

	void Texture3D::GenerateMips()
	{
		m_Texture3DSettings.HasMips = true;
		if (IsGenerated())
		{
			Bind();
			glGenerateMipmap(m_Texture3DTarget);
		}
	}

	void Texture3D::Bind(int unit) const
	{
		glActiveTexture(GL_TEXTURE0 + unit);
		glBindTexture(m_Texture3DTarget, m_Texture3DId);
	}

	void Texture3D::Unbind() const
	{
		glBindTexture(m_Texture3DTarget, 0);
	}

	void Texture3D::SetTextureWrapS(GLenum textureWrapMode)
	{
		if (m_Texture3DSettings.TextureWrapSMode == textureWrapMode)
			return;

		m_Texture3DSettings.TextureWrapSMode = textureWrapMode;
		if (IsGenerated())
		{
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_WRAP_S, m_Texture3DSettings.TextureWrapSMode);
		}
	}

	void Texture3D::SetTextureWrapT(GLenum textureWrapMode)
	{
		if (m_Texture3DSettings.TextureWrapTMode == textureWrapMode)
			return;

		m_Texture3DSettings.TextureWrapTMode = textureWrapMode;
		if (IsGenerated())
		{
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_WRAP_T, m_Texture3DSettings.TextureWrapTMode);
		}
	}

	void Texture3D::SetTextureWrapR(GLenum textureWrapMode)
	{
		if (m_Texture3DSettings.TextureWrapRMode == textureWrapMode)
			return;

		m_Texture3DSettings.TextureWrapRMode = textureWrapMode;
		if (IsGenerated())
		{
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_WRAP_R, m_Texture3DSettings.TextureWrapRMode);
		}
	}

	void Texture3D::SetHasBorder(bool hasBorder)
	{
		if (m_Texture3DSettings.HasBorder == hasBorder)
			return;

		m_Texture3DSettings.HasBorder = hasBorder;
		if (IsGenerated())
		{
			glTexParameterfv(m_Texture3DTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(m_Texture3DSettings.BorderColour));
		}
	}

	void Texture3D::SetBorderColour(glm::vec4& borderColour)
	{
		if (m_Texture3DSettings.BorderColour == borderColour || m_Texture3DSettings.HasBorder == false)
			return;

		m_Texture3DSettings.BorderColour = borderColour;
		if (IsGenerated())
		{
			glTexParameterfv(m_Texture3DTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(m_Texture3DSettings.BorderColour));
		}
	}

	void Texture3D::SetTextureMinFilter(GLenum textureFilterMode)
	{
		if (m_Texture3DSettings.TextureMinificationFilterMode == textureFilterMode)
			return;

		m_Texture3DSettings.TextureMinificationFilterMode = textureFilterMode;
		if (IsGenerated())
		{
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_MIN_FILTER, m_Texture3DSettings.TextureMinificationFilterMode);
		}
	}

	void Texture3D::SetTextureMagFilter(GLenum textureFilterMode)
	{
		ARC_ASSERT(textureFilterMode <= GL_LINEAR, "Texture's magnification filter exceeded bilinear filtering which won't result in any visual improvements and will just cost more");

		if (m_Texture3DSettings.TextureMagnificationFilterMode == textureFilterMode)
			return;

		m_Texture3DSettings.TextureMagnificationFilterMode = textureFilterMode;
		if (IsGenerated())
		{
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_MAG_FILTER, m_Texture3DSettings.TextureMagnificationFilterMode);
		}
	}

	void Texture3D::SetMipBias(int mipBias)
	{
		if (m_Texture3DSettings.MipBias == mipBias)
			return;

		m_Texture3DSettings.MipBias = mipBias;
		if (IsGenerated())
		{
			glTexParameteri(m_Texture3DTarget, GL_TEXTURE_LOD_BIAS, m_Texture3DSettings.MipBias);
		}
	}

	void Texture3D::SetHasMips(bool hasMips)
	{
		if (m_Texture3DSettings.HasMips == hasMips)
			return;

		m_Texture3DSettings.HasMips = hasMips;
		if (IsGenerated() && hasMips == true)
		{
			glGenerateMipmap(m_Texture3DTarget);
		}
	}
}
